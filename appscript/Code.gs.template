// ==========================================
// FinnanceFlow - Google Apps Script Backend
// ==========================================
// 
// üìã INSTRU√á√ïES DE CONFIGURA√á√ÉO:
// 1. Copie este arquivo para "Code.gs" no seu Google Apps Script
// 2. Configure os usu√°rios e senhas em CONFIG.USERS
// 3. Atualize ALLOWED_ORIGINS com seu dom√≠nio do GitHub Pages
// 4. Implante como Web App com acesso "Qualquer pessoa"
//
// ‚ö†Ô∏è IMPORTANTE: Nunca commite o arquivo Code.gs real com suas credenciais!
// ==========================================

// Configuration
const CONFIG = {
  SHEET_NAME: "Transacoes",
  TOKEN_SHEET: "Tokens",
  
  // ==========================================
  // üîê CONFIGURE SEUS USU√ÅRIOS AQUI
  // ==========================================
  // Substitua com seus nomes de usu√°rio e senhas reais
  USERS: {
    usuario1: "sua-senha-segura-aqui",  // ‚ö†Ô∏è ALTERE ISSO!
    usuario2: "sua-senha-segura-aqui",  // ‚ö†Ô∏è ALTERE ISSO!
  },
  
  // Token expiration in milliseconds (24 hours)
  TOKEN_EXPIRATION: 24 * 60 * 60 * 1000,
  
  // ==========================================
  // üåê CONFIGURE SUAS ORIGENS PERMITIDAS
  // ==========================================
  // Adicione seu dom√≠nio do GitHub Pages aqui
  ALLOWED_ORIGINS: [
    // Desenvolvimento local
    "http://127.0.0.1:5500",
    "http://localhost:5500",
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://127.0.0.1:8080",
    "http://localhost:8080",
    "http://127.0.0.1",
    "http://localhost",
    "https://127.0.0.1:5500",
    "https://localhost:5500",
    
    // ‚ö†Ô∏è SUBSTITUA com seu dom√≠nio real do GitHub Pages
    // Exemplo: "https://seu-usuario.github.io",
    "https://seu-usuario.github.io",
  ],
};

// ==========================================
// Main Handler
// ==========================================

function doGet(e) {
  const output = ContentService.createTextOutput(
    JSON.stringify({
      status: "FinnanceFlow API is running",
      version: "1.0.0",
    })
  ).setMimeType(ContentService.MimeType.JSON);

  // Enable CORS
  return output;
}

// Handle CORS preflight requests (OPTIONS method)
function doOptions(e) {
  return ContentService.createTextOutput('')
    .setMimeType(ContentService.MimeType.TEXT)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    .setHeader('Access-Control-Max-Age', '86400');
}

function doPost(e) {
  try {
    const origin = e.parameter.origin || (e.headers && e.headers.origin);

    // Log for debugging
    Logger.log("Request Origin: " + origin);

    const data = JSON.parse(e.postData.contents);
    const action = e.parameter.action;

    // Route to appropriate handler
    switch (action) {
      case "login":
        return handleLogin(data);

      case "validateToken":
        // Validate token for validateToken action
        if (!validateToken(data.token)) {
          return createResponse({ valid: false });
        }
        return createResponse({ valid: true });

      case "getTransactions":
      case "getTransaction":
      case "createTransaction":
      case "updateTransaction":
      case "deleteTransaction":
      case "markAsPaid":
      case "getSummary":
        // Validate token for protected routes
        const username = validateTokenAndGetUser(data.token);
        if (!username) {
          return createResponse({ error: "Invalid token" }, 401);
        }

        // Add username to data for access control
        data.currentUser = username;

        // Execute the appropriate action
        if (action === "getTransactions") return getTransactions(data);
        if (action === "getTransaction") return getTransaction(data);
        if (action === "createTransaction") return createTransaction(data);
        if (action === "updateTransaction") return updateTransaction(data);
        if (action === "deleteTransaction") return deleteTransaction(data);
        if (action === "markAsPaid") return markAsPaid(data);
        if (action === "getSummary") return getSummary(data);
        break;

      default:
        return createResponse({ error: "Invalid action" }, 400);
    }
  } catch (error) {
    Logger.log("Error: " + error.toString());
    return createResponse({ error: error.toString() }, 500);
  }
}

// ==========================================
// Authentication
// ==========================================

function handleLogin(data) {
  const username = data.username;
  const password = data.password;

  // Validate credentials
  if (!CONFIG.USERS[username] || CONFIG.USERS[username] !== password) {
    return createResponse(
      {
        success: false,
        error: "Usu√°rio ou senha inv√°lidos",
      },
      401
    );
  }

  // Generate token
  const token = generateToken(username);

  // Save token
  saveToken(token, username);

  // Get all usernames for the system
  const allUsers = Object.keys(CONFIG.USERS);

  return createResponse({
    success: true,
    token: token,
    userData: {
      username: username,
      person: username,
      allUsers: allUsers, // Send all registered users
    },
  });
}

function validateToken(token) {
  if (!token) return false;

  const tokenSheet = getTokenSheet();
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return false;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();

  for (let i = 0; i < tokens.length; i++) {
    const [storedToken, username, expiration] = tokens[i];

    if (storedToken === token) {
      // Check if token is expired
      if (new Date() > new Date(expiration)) {
        // Token expired, delete it
        tokenSheet.deleteRow(i + 2);
        return false;
      }
      return true;
    }
  }

  return false;
}

function validateTokenAndGetUser(token) {
  if (!token) return null;

  const tokenSheet = getTokenSheet();
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return null;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();

  for (let i = 0; i < tokens.length; i++) {
    const [storedToken, username, expiration] = tokens[i];

    if (storedToken === token) {
      // Check if token is expired
      if (new Date() > new Date(expiration)) {
        // Token expired, delete it
        tokenSheet.deleteRow(i + 2);
        return null;
      }
      return username;
    }
  }

  return null;
}

function generateToken(username) {
  const timestamp = new Date().getTime();
  const random = Math.random().toString(36).substring(2, 15);
  return `${username}_${timestamp}_${random}`;
}

function saveToken(token, username) {
  const tokenSheet = getTokenSheet();
  const expiration = new Date(new Date().getTime() + CONFIG.TOKEN_EXPIRATION);

  // Clean expired tokens
  cleanExpiredTokens(tokenSheet);

  // Save new token
  tokenSheet.appendRow([token, username, expiration]);
}

function cleanExpiredTokens(tokenSheet) {
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();
  const now = new Date();

  // Delete from bottom to top to avoid index issues
  for (let i = tokens.length - 1; i >= 0; i--) {
    const expiration = new Date(tokens[i][2]);
    if (now > expiration) {
      tokenSheet.deleteRow(i + 2);
    }
  }
}

function getTokenSheet() {
  const ss = getSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.TOKEN_SHEET);

  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.TOKEN_SHEET);
    sheet.getRange(1, 1, 1, 3).setValues([["Token", "Username", "Expiration"]]);
    sheet.getRange(1, 1, 1, 3).setFontWeight("bold");
    sheet.setFrozenRows(1);
  }

  return sheet;
}

// ==========================================
// Spreadsheet Helpers
// ==========================================

function getSpreadsheet() {
  return SpreadsheetApp.getActiveSpreadsheet();
}

function getSheet(sheetName = CONFIG.SHEET_NAME) {
  const ss = getSpreadsheet();
  let sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    initializeSheet(sheet);
  }

  return sheet;
}

function initializeSheet(sheet) {
  // Set headers
  const headers = [
    "ID",
    "Descri√ß√£o",
    "Valor",
    "Tipo",
    "Pessoa",
    "Categoria",
    "Data Vencimento",
    "Status",
    "Observa√ß√µes",
    "Recorrente",
    "Data Cria√ß√£o",
    "Data Atualiza√ß√£o",
  ];

  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
  sheet.setFrozenRows(1);
}

// ==========================================
// CRUD Operations
// ==========================================

function getTransactions(data) {
  const sheet = getSheet();
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return createResponse({
      transactions: [],
      month: data.month || new Date().getMonth() + 1,
      year: data.year || new Date().getFullYear(),
    });
  }

  const range = sheet.getRange(2, 1, lastRow - 1, 12);
  const values = range.getValues();

  let transactions = values
    .map((row) => ({
      id: row[0],
      description: row[1],
      amount: row[2],
      type: row[3],
      person: row[4],
      category: row[5],
      dueDate: formatDate(row[6]),
      status: row[7],
      notes: row[8],
      isRecurring: row[9] || false,
      createdAt: row[10],
      updatedAt: row[11],
    }))
    .filter((t) => t.id); // Filter out empty rows

  // Apply month/year filter (default to current month/year)
  const filterMonth = data.month || new Date().getMonth() + 1;
  const filterYear = data.year || new Date().getFullYear();

  transactions = transactions.filter((t) => {
    if (!t.dueDate) return false;
    const date = new Date(t.dueDate);
    return (
      date.getMonth() + 1 === filterMonth && date.getFullYear() === filterYear
    );
  });

  // Apply user access control - only show own transactions and shared
  const currentUser = data.currentUser;
  transactions = transactions.filter(
    (t) => t.person === currentUser || t.person === "shared"
  );

  // Apply view filter (only if user is viewing their own or shared)
  if (data.view && data.view !== "geral" && data.view !== currentUser) {
    // User trying to view someone else's data - return empty
    transactions = [];
  }

  return createResponse({
    transactions,
    month: filterMonth,
    year: filterYear,
  });
}

function getTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const values = sheet.getRange(row, 1, 1, 12).getValues()[0];

  const transaction = {
    id: values[0],
    description: values[1],
    amount: values[2],
    type: values[3],
    person: values[4],
    category: values[5],
    dueDate: formatDate(values[6]),
    status: values[7],
    notes: values[8],
    isRecurring: values[9] || false,
    createdAt: values[10],
    updatedAt: values[11],
  };

  return createResponse({ transaction });
}

function createTransaction(data) {
  const sheet = getSheet();
  const id = generateId();
  const now = new Date();
  const isRecurring = data.isRecurring || false;

  const row = [
    id,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    new Date(data.dueDate),
    data.status || "pending",
    data.notes || "",
    isRecurring,
    now,
    now,
  ];

  sheet.appendRow(row);

  // If recurring, create next month's transaction automatically
  if (isRecurring) {
    createNextRecurringTransaction(data, sheet);
  }

  return createResponse({
    success: true,
    id: id,
    message: isRecurring
      ? "Transa√ß√£o recorrente criada com sucesso"
      : "Transaction created successfully",
  });
}

function updateTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const now = new Date();

  const updates = [
    data.id,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    new Date(data.dueDate),
    data.status || "pending",
    data.notes || "",
    data.isRecurring || false,
    sheet.getRange(row, 11).getValue(), // Keep original createdAt
    now,
  ];

  sheet.getRange(row, 1, 1, 12).setValues([updates]);

  return createResponse({
    success: true,
    message: "Transaction updated successfully",
  });
}

function deleteTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  sheet.deleteRow(row);

  return createResponse({
    success: true,
    message: "Transaction deleted successfully",
  });
}

function markAsPaid(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const isRecurring = sheet.getRange(row, 10).getValue();

  sheet.getRange(row, 8).setValue("paid"); // Status column
  sheet.getRange(row, 12).setValue(new Date()); // Updated at

  // If recurring, create next month's transaction
  if (isRecurring) {
    const values = sheet.getRange(row, 1, 1, 12).getValues()[0];
    const nextMonthData = {
      description: values[1],
      amount: values[2],
      type: values[3],
      person: values[4],
      category: values[5],
      dueDate: getNextMonthDate(values[6]),
      status: "pending",
      notes: values[8],
      isRecurring: true,
    };
    createTransaction(nextMonthData);
  }

  return createResponse({
    success: true,
    message: isRecurring
      ? "Transa√ß√£o paga e pr√≥xima recorr√™ncia criada"
      : "Transaction marked as paid",
  });
}

// ==========================================
// Summary/Statistics
// ==========================================

function getSummary(data) {
  const sheet = getSheet();
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return createResponse({
      totalIncome: 0,
      totalExpense: 0,
      totalPending: 0,
      balance: 0,
    });
  }

  const range = sheet.getRange(2, 1, lastRow - 1, 12);
  const values = range.getValues();

  // Apply month/year filter (default to current month/year)
  const filterMonth = data.month || new Date().getMonth() + 1;
  const filterYear = data.year || new Date().getFullYear();

  let transactions = values
    .map((row) => ({
      amount: row[2],
      type: row[3],
      person: row[4],
      dueDate: row[6],
      status: row[7],
    }))
    .filter((t) => {
      if (!t.amount) return false;
      if (!t.dueDate) return false;
      const date = new Date(t.dueDate);
      return (
        date.getMonth() + 1 === filterMonth && date.getFullYear() === filterYear
      );
    });

  // Apply view filter
  const currentUser = data.currentUser;

  // Apply user access control - only show own transactions and shared
  transactions = transactions.filter(
    (t) => t.person === currentUser || t.person === "shared"
  );

  // Apply view filter (only if user is viewing their own or shared)
  if (data.view && data.view !== "geral" && data.view !== currentUser) {
    // User trying to view someone else's data - return empty
    transactions = [];
  }

  const summary = {
    totalIncome: 0,
    totalExpense: 0,
    totalPending: 0,
  };

  transactions.forEach((t) => {
    if (t.type === "income") {
      summary.totalIncome += t.amount;
    } else if (t.type === "expense") {
      summary.totalExpense += t.amount;
    }

    if (t.status === "pending") {
      summary.totalPending += t.amount;
    }
  });

  summary.balance = summary.totalIncome - summary.totalExpense;

  return createResponse(summary);
}

// ==========================================
// Helper Functions
// ==========================================

function findRowById(sheet, id) {
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return -1;
  }

  const ids = sheet.getRange(2, 1, lastRow - 1, 1).getValues();

  for (let i = 0; i < ids.length; i++) {
    if (ids[i][0] === id) {
      return i + 2; // +2 because array is 0-indexed and row 1 is header
    }
  }

  return -1;
}

function createNextRecurringTransaction(data, sheet) {
  const nextId = generateId();
  const now = new Date();
  const nextDueDate = getNextMonthDate(data.dueDate);

  const row = [
    nextId,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    nextDueDate,
    "pending",
    data.notes || "",
    true, // isRecurring
    now,
    now,
  ];

  sheet.appendRow(row);
}

function getNextMonthDate(currentDate) {
  const date = new Date(currentDate);
  const nextMonth = new Date(
    date.getFullYear(),
    date.getMonth() + 1,
    date.getDate()
  );

  // Handle cases where the day doesn't exist in next month (e.g., Jan 31 -> Feb 28)
  if (nextMonth.getDate() !== date.getDate()) {
    nextMonth.setDate(0); // Set to last day of previous month
  }

  return nextMonth;
}

function generateId() {
  return (
    "TXN_" +
    new Date().getTime() +
    "_" +
    Math.random().toString(36).substr(2, 9)
  );
}

function formatDate(date) {
  if (!date) return "";

  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");

  return `${year}-${month}-${day}`;
}

// ==========================================
// CORS Helpers
// ==========================================

function isOriginAllowed(origin) {
  if (!origin) return true; // Allow if no origin specified

  // Check exact match
  if (CONFIG.ALLOWED_ORIGINS.includes(origin)) {
    return true;
  }

  // Check if origin matches pattern (for GitHub Pages subdomains)
  for (const allowedOrigin of CONFIG.ALLOWED_ORIGINS) {
    if (allowedOrigin.includes("github.io")) {
      // Allow any GitHub Pages subdomain
      if (origin.includes("github.io")) {
        return true;
      }
    }
  }

  return false;
}

function createResponse(data, status = 200) {
  const jsonOutput = JSON.stringify(data);
  const output = ContentService.createTextOutput(jsonOutput);

  // Set CORS headers to allow localhost and Live Server
  output.setMimeType(ContentService.MimeType.JSON);

  // Note: Apps Script doesn't support custom headers in Web Apps
  // But deploying as "Anyone" should allow cross-origin requests
  return output;
}
