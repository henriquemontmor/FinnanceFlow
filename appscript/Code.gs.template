// ==========================================
// FinnanceFlow - Google Apps Script Backend
// ==========================================
// 
// üìã INSTRU√á√ïES DE CONFIGURA√á√ÉO:
// 1. Copie este arquivo para "Code.gs" no seu Google Apps Script
// 2. Configure os usu√°rios e senhas em CONFIG.USERS
// 3. Atualize ALLOWED_ORIGINS com seu dom√≠nio do GitHub Pages
// 4. Implante como Web App com acesso "Qualquer pessoa"
//
// ‚ö†Ô∏è IMPORTANTE: Nunca commite o arquivo Code.gs real com suas credenciais!
// ==========================================

// Configuration
const CONFIG = {
  SHEET_NAME: "Transacoes",
  TOKEN_SHEET: "Tokens",
  CARDS_SHEET: "Cartoes",
  
  // ==========================================
  // üîê CONFIGURE SEUS USU√ÅRIOS AQUI
  // ==========================================
  // Substitua com seus nomes de usu√°rio e senhas reais
  USERS: {
    usuario1: "sua-senha-segura-aqui",  // ‚ö†Ô∏è ALTERE ISSO!
    usuario2: "sua-senha-segura-aqui",  // ‚ö†Ô∏è ALTERE ISSO!
  },
  
  // Token expiration in milliseconds (72 hours)
  TOKEN_EXPIRATION: 72 * 60 * 60 * 1000,
  
  // ==========================================
  // üåê CONFIGURE SUAS ORIGENS PERMITIDAS
  // ==========================================
  // Adicione seu dom√≠nio do GitHub Pages aqui
  ALLOWED_ORIGINS: [
    // Desenvolvimento local
    "http://127.0.0.1:5500",
    "http://localhost:5500",
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://127.0.0.1:8080",
    "http://localhost:8080",
    "http://127.0.0.1",
    "http://localhost",
    "https://127.0.0.1:5500",
    "https://localhost:5500",
    
    // ‚ö†Ô∏è SUBSTITUA com seu dom√≠nio real do GitHub Pages
    // Exemplo: "https://seu-usuario.github.io",
    "https://seu-usuario.github.io",
  ],
};

// ==========================================
// Main Handler
// ==========================================

function doGet(e) {
  const output = ContentService.createTextOutput(
    JSON.stringify({
      status: "FinnanceFlow API is running",
      version: "1.0.0",
    })
  ).setMimeType(ContentService.MimeType.JSON);

  // Enable CORS
  return output;
}

// Handle CORS preflight requests (OPTIONS method)
function doOptions(e) {
  return ContentService.createTextOutput("")
    .setMimeType(ContentService.MimeType.TEXT)
    .setHeader("Access-Control-Allow-Origin", "*")
    .setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
    .setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization")
    .setHeader("Access-Control-Max-Age", "86400");
}

function doPost(e) {
  try {
    const origin = e.parameter.origin || (e.headers && e.headers.origin);

    // Log for debugging
    Logger.log("Request Origin: " + origin);

    const data = JSON.parse(e.postData.contents);
    const action = e.parameter.action;

    // Route to appropriate handler
    switch (action) {
      case "login":
        return handleLogin(data);

      case "validateToken":
        // Validate token for validateToken action
        if (!validateToken(data.token)) {
          return createResponse({ valid: false });
        }
        return createResponse({ valid: true });

      case "getTransactions":
      case "getTransaction":
      case "createTransaction":
      case "updateTransaction":
      case "deleteTransaction":
      case "markAsPaid":
      case "getSummary":
      case "getCards":
      case "createCard":
      case "updateCard":
      case "deleteCard":
        // Validate token for protected routes
        const username = validateTokenAndGetUser(data.token);
        if (!username) {
          return createResponse({ error: "Invalid token" }, 401);
        }

        // Add username to data for access control
        data.currentUser = username;

        // Execute the appropriate action
        if (action === "getTransactions") return getTransactions(data);
        if (action === "getTransaction") return getTransaction(data);
        if (action === "createTransaction") return createTransaction(data);
        if (action === "updateTransaction") return updateTransaction(data);
        if (action === "deleteTransaction") return deleteTransaction(data);
        if (action === "markAsPaid") return markAsPaid(data);
        if (action === "getSummary") return getSummary(data);
        if (action === "getCards") return getCards(data);
        if (action === "createCard") return createCard(data);
        if (action === "updateCard") return updateCard(data);
        if (action === "deleteCard") return deleteCard(data);
        break;

      default:
        return createResponse({ error: "Invalid action" }, 400);
    }
  } catch (error) {
    Logger.log("Error: " + error.toString());
    return createResponse({ error: error.toString() }, 500);
  }
}

// ==========================================
// Authentication
// ==========================================

function handleLogin(data) {
  const username = data.username;
  const password = data.password;

  // Validate credentials
  if (!CONFIG.USERS[username] || CONFIG.USERS[username] !== password) {
    return createResponse(
      {
        success: false,
        error: "Usu√°rio ou senha inv√°lidos",
      },
      401
    );
  }

  // Generate token
  const token = generateToken(username);

  // Save token
  saveToken(token, username);

  // Get all usernames for the system
  const allUsers = Object.keys(CONFIG.USERS);

  return createResponse({
    success: true,
    token: token,
    userData: {
      username: username,
      person: username,
      allUsers: allUsers, // Send all registered users
    },
  });
}

function validateToken(token) {
  if (!token) return false;

  const tokenSheet = getTokenSheet();
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return false;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();

  for (let i = 0; i < tokens.length; i++) {
    const [storedToken, username, expiration] = tokens[i];

    if (storedToken === token) {
      // Check if token is expired
      if (new Date() > new Date(expiration)) {
        // Token expired, delete it
        tokenSheet.deleteRow(i + 2);
        return false;
      }
      return true;
    }
  }

  return false;
}

function validateTokenAndGetUser(token) {
  if (!token) return null;

  const tokenSheet = getTokenSheet();
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return null;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();

  for (let i = 0; i < tokens.length; i++) {
    const [storedToken, username, expiration] = tokens[i];

    if (storedToken === token) {
      // Check if token is expired
      if (new Date() > new Date(expiration)) {
        // Token expired, delete it
        tokenSheet.deleteRow(i + 2);
        return null;
      }
      return username;
    }
  }

  return null;
}

function generateToken(username) {
  const timestamp = new Date().getTime();
  const random = Math.random().toString(36).substring(2, 15);
  return `${username}_${timestamp}_${random}`;
}

function saveToken(token, username) {
  const tokenSheet = getTokenSheet();
  const expiration = new Date(new Date().getTime() + CONFIG.TOKEN_EXPIRATION);

  // Clean expired tokens
  cleanExpiredTokens(tokenSheet);

  // Save new token
  tokenSheet.appendRow([token, username, expiration]);
}

function cleanExpiredTokens(tokenSheet) {
  const lastRow = tokenSheet.getLastRow();

  if (lastRow < 2) return;

  const tokens = tokenSheet.getRange(2, 1, lastRow - 1, 3).getValues();
  const now = new Date();

  // Delete from bottom to top to avoid index issues
  for (let i = tokens.length - 1; i >= 0; i--) {
    const expiration = new Date(tokens[i][2]);
    if (now > expiration) {
      tokenSheet.deleteRow(i + 2);
    }
  }
}

function getTokenSheet() {
  const ss = getSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.TOKEN_SHEET);

  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.TOKEN_SHEET);
    sheet.getRange(1, 1, 1, 3).setValues([["Token", "Username", "Expiration"]]);
    sheet.getRange(1, 1, 1, 3).setFontWeight("bold");
    sheet.setFrozenRows(1);
  }

  return sheet;
}

// ==========================================
// Spreadsheet Helpers
// ==========================================

function getSpreadsheet() {
  return SpreadsheetApp.getActiveSpreadsheet();
}

function getSheet(sheetName = CONFIG.SHEET_NAME) {
  const ss = getSpreadsheet();
  let sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    initializeSheet(sheet);
  }

  return sheet;
}

function initializeSheet(sheet) {
  // Set headers
  const headers = [
    "ID",
    "Descri√ß√£o",
    "Valor",
    "Tipo",
    "Pessoa",
    "Categoria",
    "Data Vencimento",
    "Status",
    "Observa√ß√µes",
    "Recorrente",
    "Data Cria√ß√£o",
    "Data Atualiza√ß√£o",
    "ID Cart√£o",
    "Parcela Atual",
    "Total Parcelas",
  ];

  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");
  sheet.setFrozenRows(1);
}

// ==========================================
// CRUD Operations
// ==========================================

function getTransactions(data) {
  const sheet = getSheet();
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return createResponse({
      transactions: [],
      month: data.month || new Date().getMonth() + 1,
      year: data.year || new Date().getFullYear(),
    });
  }

  const range = sheet.getRange(2, 1, lastRow - 1, 15);
  const values = range.getValues();

  let transactions = values
    .map((row) => ({
      id: row[0],
      description: row[1],
      amount: row[2],
      type: row[3],
      person: row[4],
      category: row[5],
      dueDate: formatDate(row[6]),
      status: row[7],
      notes: row[8],
      isRecurring: row[9] || false,
      createdAt: row[10],
      updatedAt: row[11],
      cardId: row[12] || null,
      currentInstallment: row[13] || null,
      totalInstallments: row[14] || null,
    }))
    .filter((t) => t.id); // Filter out empty rows

  // Apply month/year filter (default to current month/year)
  const filterMonth = data.month || new Date().getMonth() + 1;
  const filterYear = data.year || new Date().getFullYear();

  transactions = transactions.filter((t) => {
    if (!t.dueDate) return false;
    const date = new Date(t.dueDate);
    return (
      date.getMonth() + 1 === filterMonth && date.getFullYear() === filterYear
    );
  });

  // Apply user access control and view filter
  const currentUser = data.currentUser;

  if (data.view === "geral") {
    // Show only shared transactions
    transactions = transactions.filter((t) => t.person === "shared");
  } else if (data.view === currentUser || !data.view) {
    // Show user's own transactions + shared
    transactions = transactions.filter(
      (t) => t.person === currentUser || t.person === "shared"
    );
  } else {
    // User trying to view someone else's data - return empty
    transactions = [];
  }

  return createResponse({
    transactions,
    month: filterMonth,
    year: filterYear,
  });
}

function getTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const values = sheet.getRange(row, 1, 1, 15).getValues()[0];

  const transaction = {
    id: values[0],
    description: values[1],
    amount: values[2],
    type: values[3],
    person: values[4],
    category: values[5],
    dueDate: formatDate(values[6]),
    status: values[7],
    notes: values[8],
    isRecurring: values[9] || false,
    createdAt: values[10],
    updatedAt: values[11],
    cardId: values[12] || null,
    currentInstallment: values[13] || null,
    totalInstallments: values[14] || null,
  };

  return createResponse({ transaction });
}

function createTransaction(data) {
  // Check if this is an installment purchase
  if (data.installments && data.installments > 1 && data.cardId) {
    // Get card information
    const cardsSheet = getCardsSheet();
    const cardRow = findRowById(cardsSheet, data.cardId);

    if (cardRow === -1) {
      return createResponse({ error: "Card not found" }, 404);
    }

    const cardValues = cardsSheet.getRange(cardRow, 1, 1, 6).getValues()[0];
    const card = {
      id: cardValues[0],
      name: cardValues[1],
      dueDay: cardValues[2],
      closingDay: cardValues[3],
    };

    // Create installment transactions
    const createdIds = createInstallmentTransactions(data, card);

    return createResponse({
      success: true,
      ids: createdIds,
      message: `${data.installments} parcelas criadas com sucesso`,
    });
  }

  // Regular transaction (not installment)
  const sheet = getSheet();
  const id = generateId();
  const now = new Date();
  const isRecurring = data.isRecurring || false;

  const row = [
    id,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    new Date(data.dueDate),
    data.status || "pending",
    data.notes || "",
    isRecurring,
    now,
    now,
    null, // cardId
    null, // currentInstallment
    null, // totalInstallments
  ];

  sheet.appendRow(row);

  // Check if category is a user name (transfer between users)
  const categoryLower = (data.category || "").toLowerCase();
  const userNames = Object.keys(CONFIG.USERS).map(u => u.toLowerCase());
  
  if (data.type === "expense" && userNames.includes(categoryLower)) {
    // This is a transfer! Create reciprocal income transaction for the receiver
    const receiverName = categoryLower.charAt(0).toUpperCase() + categoryLower.slice(1);
    const reciprocalId = generateId();
    
    const reciprocalRow = [
      reciprocalId,
      `Transfer√™ncia de ${data.person}`, // Description shows who sent it
      data.amount,
      "income", // Income for receiver
      receiverName.toLowerCase(), // Person is the receiver
      "particular", // Category for income
      new Date(data.dueDate),
      data.status || "pending", // Same status as original
      `Origem: ${data.description}`, // Notes reference original transaction
      false, // Not recurring
      now,
      now,
      null, // cardId
      null, // currentInstallment
      null, // totalInstallments
    ];
    
    sheet.appendRow(reciprocalRow);
  }

  // If recurring, create next month's transaction automatically
  if (isRecurring) {
    createNextRecurringTransaction(data, sheet);
  }

  return createResponse({
    success: true,
    id: id,
    message: isRecurring
      ? "Transa√ß√£o recorrente criada com sucesso"
      : "Transaction created successfully",
  });
}

function updateTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const now = new Date();

  const updates = [
    data.id,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    new Date(data.dueDate),
    data.status || "pending",
    data.notes || "",
    data.isRecurring || false,
    sheet.getRange(row, 11).getValue(), // Keep original createdAt
    now,
    sheet.getRange(row, 13).getValue() || null, // Keep cardId
    sheet.getRange(row, 14).getValue() || null, // Keep currentInstallment
    sheet.getRange(row, 15).getValue() || null, // Keep totalInstallments
  ];

  sheet.getRange(row, 1, 1, 15).setValues([updates]);

  return createResponse({
    success: true,
    message: "Transaction updated successfully",
  });
}

function deleteTransaction(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  sheet.deleteRow(row);

  return createResponse({
    success: true,
    message: "Transaction deleted successfully",
  });
}

function markAsPaid(data) {
  const sheet = getSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Transaction not found" }, 404);
  }

  const isRecurring = sheet.getRange(row, 10).getValue();

  sheet.getRange(row, 8).setValue("paid"); // Status column
  sheet.getRange(row, 12).setValue(new Date()); // Updated at

  // If recurring, create next month's transaction
  if (isRecurring) {
    const values = sheet.getRange(row, 1, 1, 12).getValues()[0];
    const nextMonthData = {
      description: values[1],
      amount: values[2],
      type: values[3],
      person: values[4],
      category: values[5],
      dueDate: getNextMonthDate(values[6]),
      status: "pending",
      notes: values[8],
      isRecurring: true,
    };
    createTransaction(nextMonthData);
  }

  return createResponse({
    success: true,
    message: isRecurring
      ? "Transa√ß√£o paga e pr√≥xima recorr√™ncia criada"
      : "Transaction marked as paid",
  });
}

// ==========================================
// Summary/Statistics
// ==========================================

function getSummary(data) {
  const sheet = getSheet();
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return createResponse({
      totalIncome: 0,
      totalExpense: 0,
      totalPending: 0,
      balance: 0,
    });
  }

  const range = sheet.getRange(2, 1, lastRow - 1, 12);
  const values = range.getValues();

  // Apply month/year filter (default to current month/year)
  const filterMonth = data.month || new Date().getMonth() + 1;
  const filterYear = data.year || new Date().getFullYear();

  let transactions = values
    .map((row) => ({
      amount: row[2],
      type: row[3],
      person: row[4],
      dueDate: row[6],
      status: row[7],
    }))
    .filter((t) => {
      if (!t.amount) return false;
      if (!t.dueDate) return false;
      const date = new Date(t.dueDate);
      return (
        date.getMonth() + 1 === filterMonth && date.getFullYear() === filterYear
      );
    });

  // Apply view filter
  const currentUser = data.currentUser;

  if (data.view === "geral") {
    // Show only shared transactions
    transactions = transactions.filter((t) => t.person === "shared");
  } else if (data.view === currentUser || !data.view) {
    // Show only user's own transactions (NOT shared)
    transactions = transactions.filter((t) => t.person === currentUser);
  } else {
    // User trying to view someone else's data - return empty
    transactions = [];
  }

  const summary = {
    totalIncome: 0,
    totalExpense: 0,
    totalPending: 0,
    totalCard: 0,
    totalCardPending: 0,
    totalSavings: 0,
  };

  transactions.forEach((t) => {
    // Cart√£o: separado, n√£o entra nos totais principais
    if (t.type === "cartao") {
      summary.totalCard += t.amount;
      if (t.status === "pending") {
        summary.totalCardPending += t.amount;
      }
      return;
    }

    // Caixinha: adiciona ao guardado
    if (t.type === "caixinha") {
      summary.totalSavings += t.amount;
      return;
    }

    // Retirada da caixinha: subtrai do guardado
    if (t.type === "retirada-caixinha") {
      summary.totalSavings -= t.amount;
      return;
    }

    // Transa√ß√µes normais (income/expense)
    if (t.type === "income") {
      summary.totalIncome += t.amount;
    } else if (t.type === "expense") {
      summary.totalExpense += t.amount;
    }

    if (t.status === "pending") {
      summary.totalPending += t.amount;
    }
  });

  summary.balance = summary.totalIncome - summary.totalExpense;

  return createResponse(summary);
}

// ==========================================
// Helper Functions
// ==========================================

function findRowById(sheet, id) {
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return -1;
  }

  const ids = sheet.getRange(2, 1, lastRow - 1, 1).getValues();

  for (let i = 0; i < ids.length; i++) {
    if (ids[i][0] === id) {
      return i + 2; // +2 because array is 0-indexed and row 1 is header
    }
  }

  return -1;
}

function createNextRecurringTransaction(data, sheet) {
  const nextId = generateId();
  const now = new Date();
  const nextDueDate = getNextMonthDate(data.dueDate);

  const row = [
    nextId,
    data.description,
    data.amount,
    data.type,
    data.person,
    data.category || "outros",
    nextDueDate,
    "pending",
    data.notes || "",
    true, // isRecurring
    now,
    now,
  ];

  sheet.appendRow(row);
}

function getNextMonthDate(currentDate) {
  const date = new Date(currentDate);
  const nextMonth = new Date(
    date.getFullYear(),
    date.getMonth() + 1,
    date.getDate()
  );

  // Handle cases where the day doesn't exist in next month (e.g., Jan 31 -> Feb 28)
  if (nextMonth.getDate() !== date.getDate()) {
    nextMonth.setDate(0); // Set to last day of previous month
  }

  return nextMonth;
}

function generateId() {
  return (
    "TXN_" +
    new Date().getTime() +
    "_" +
    Math.random().toString(36).substr(2, 9)
  );
}

function formatDate(date) {
  if (!date) return "";

  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");

  return `${year}-${month}-${day}`;
}

// ==========================================
// CORS Helpers
// ==========================================

function isOriginAllowed(origin) {
  if (!origin) return true; // Allow if no origin specified

  // Check exact match
  if (CONFIG.ALLOWED_ORIGINS.includes(origin)) {
    return true;
  }

  // Check if origin matches pattern (for GitHub Pages subdomains)
  for (const allowedOrigin of CONFIG.ALLOWED_ORIGINS) {
    if (allowedOrigin.includes("github.io")) {
      // Allow any GitHub Pages subdomain
      if (origin.includes("github.io")) {
        return true;
      }
    }
  }

  return false;
}

function createResponse(data, status = 200) {
  const jsonOutput = JSON.stringify(data);
  const output = ContentService.createTextOutput(jsonOutput);

  // Set CORS headers to allow localhost and Live Server
  output.setMimeType(ContentService.MimeType.JSON);

  // Note: Apps Script doesn't support custom headers in Web Apps
  // But deploying as "Anyone" should allow cross-origin requests
  return output;
}

// ==========================================
// Credit Cards Management
// ==========================================

function getCardsSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(CONFIG.CARDS_SHEET);

  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.CARDS_SHEET);
    // Setup headers
    sheet
      .getRange(1, 1, 1, 6)
      .setValues([
        [
          "ID",
          "Nome",
          "Dia Vencimento",
          "Dia Fechamento",
          "Criado Em",
          "Atualizado Em",
        ],
      ]);
    sheet.getRange(1, 1, 1, 6).setFontWeight("bold");
  }

  return sheet;
}

function getCards(data) {
  const sheet = getCardsSheet();
  const lastRow = sheet.getLastRow();

  if (lastRow < 2) {
    return createResponse({ cards: [] });
  }

  const range = sheet.getRange(2, 1, lastRow - 1, 6);
  const values = range.getValues();

  const cards = values
    .map((row) => ({
      id: row[0],
      name: row[1],
      dueDay: row[2],
      closingDay: row[3],
      createdAt: row[4],
      updatedAt: row[5],
    }))
    .filter((c) => c.id);

  return createResponse({ cards });
}

function createCard(data) {
  const sheet = getCardsSheet();
  const id = Utilities.getUuid();
  const now = new Date().toISOString();

  sheet.appendRow([id, data.name, data.dueDay, data.closingDay, now, now]);

  return createResponse({
    success: true,
    card: {
      id,
      name: data.name,
      dueDay: data.dueDay,
      closingDay: data.closingDay,
      createdAt: now,
      updatedAt: now,
    },
  });
}

function updateCard(data) {
  const sheet = getCardsSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Card not found" }, 404);
  }

  const now = new Date().toISOString();

  sheet
    .getRange(row, 2, 1, 5)
    .setValues([
      [
        data.name,
        data.dueDay,
        data.closingDay,
        sheet.getRange(row, 5).getValue(),
        now,
      ],
    ]);

  return createResponse({
    success: true,
    message: "Card updated successfully",
  });
}

function deleteCard(data) {
  const sheet = getCardsSheet();
  const row = findRowById(sheet, data.id);

  if (row === -1) {
    return createResponse({ error: "Card not found" }, 404);
  }

  sheet.deleteRow(row);
  return createResponse({
    success: true,
    message: "Card deleted successfully",
  });
}

// ==========================================
// Installment Calculation
// ==========================================

/**
 * Calculate the due date for an installment based on card's closing and due days
 * @param {Date} purchaseDate - Date of purchase
 * @param {number} closingDay - Day of month when card closes
 * @param {number} dueDay - Day of month when invoice is due
 * @param {number} installmentNumber - Which installment (0-based)
 * @returns {string} Due date in YYYY-MM-DD format
 */
function calculateInstallmentDate(purchaseDate, closingDay, dueDay, installmentNumber) {
  const date = new Date(purchaseDate);
  const purchaseDay = date.getDate();

  // Calculate months to add based on installment number
  let monthsToAdd = installmentNumber;

  // If purchase is after closing day, ALL installments start from next month's invoice
  if (purchaseDay > closingDay) {
    monthsToAdd += 1;
  }

  // Add months
  date.setMonth(date.getMonth() + monthsToAdd);

  // Set to invoice due day (not closing day)
  date.setDate(dueDay);

  return Utilities.formatDate(date, Session.getScriptTimeZone(), "yyyy-MM-dd");
}/**
 * Create installment transactions
 * @param {object} data - Transaction data with installment info
 * @param {object} card - Card data with closing day
 * @returns {Array} Array of created transaction IDs
 */
function createInstallmentTransactions(data, card) {
  const sheet = getSheet();
  const installments = data.installments;
  const amountPerInstallment = data.amount / installments;
  const createdIds = [];

  for (let i = 0; i < installments; i++) {
    const id = Utilities.getUuid();
    const now = new Date().toISOString();
    const dueDate = calculateInstallmentDate(data.dueDate, card.closingDay, card.dueDay, i);

    // Add label: √† vista for single payment, or installment number
    let description;
    if (installments === 1) {
      description = `${data.description} (√† vista)`;
    } else {
      description = `${data.description} (${i + 1}/${installments})`;
    }

    sheet.appendRow([
      id,
      description,
      amountPerInstallment,
      data.type,
      data.person,
      data.category || "",
      dueDate,
      data.status || "pending",
      data.notes || "",
      false, // isRecurring
      now,
      now,
      card.id, // cardId
      i + 1, // currentInstallment
      installments, // totalInstallments
    ]);

    createdIds.push(id);
  }

  return createdIds;
}
